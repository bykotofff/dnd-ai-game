// frontend/src/lib/socket-client.ts
import { io, Socket } from 'socket.io-client'
import { useGameStore } from '@/stores/game-store'
import { useAuthStore } from '@/stores/auth-store'
import {
    SocketGameAction,
    SocketDiceRoll,
    SocketChatMessage,
    ActionLog,
    AIResponse,
    SessionPlayer,
    CombatState,
    InitiativeEntry
} from '@/types'
import toast from 'react-hot-toast'

interface ServerToClientEvents {
    // –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
    connected: (data: { message: string; userId: string; socketId: string }) => void
    error: (data: { message: string }) => void

    // –°–µ—Å—Å–∏–∏
    session_joined: (data: { sessionId: string; message: string }) => void
    session_state: (data: any) => void
    player_joined: (data: { userId: string; username: string; timestamp: Date }) => void
    player_left: (data: { userId: string; username: string; timestamp: Date }) => void

    // –ò–≥—Ä–æ–≤—ã–µ —Å–æ–±—ã—Ç–∏—è
    game_action: (action: SocketGameAction & { playerName: string; timestamp: Date }) => void
    ai_response: (response: AIResponse) => void
    dice_roll: (rollResult: SocketDiceRoll & { playerId: string; playerName: string; timestamp: Date }) => void
    chat_message: (message: SocketChatMessage & { playerId: string; playerName: string; timestamp: Date }) => void
    character_update: (update: { characterId: string; updates: any; updatedBy: string; timestamp: Date }) => void

    // –ò–≥—Ä–æ–≤—ã–µ –º–µ—Ö–∞–Ω–∏–∫–∏
    player_turn: (data: { playerId: string; playerName: string; message: string; timestamp: Date }) => void
    initiative_update: (data: { initiativeOrder: InitiativeEntry[]; timestamp: Date }) => void
    combat_state_change: (data: { inCombat: boolean; round?: number; timestamp: Date }) => void
    scene_change: (data: { scene: string; description: string; imageUrl?: string; timestamp: Date }) => void
    quest_update: (data: { questId: string; questName: string; status: string; description?: string; timestamp: Date }) => void
    game_event: (data: { type: string; data: Record<string, any>; timestamp: Date }) => void

    // –°–∏—Å—Ç–µ–º–Ω—ã–µ
    pong: (data: { timestamp: number }) => void
    force_disconnect: (data: { reason: string }) => void
}

interface ClientToServerEvents {
    join_session: (data: { sessionId: string }) => void
    leave_session: (data: { sessionId: string }) => void
    get_session_state: (data: { sessionId: string }) => void
    game_action: (action: SocketGameAction) => void
    dice_roll: (diceRoll: SocketDiceRoll) => void
    chat_message: (data: SocketChatMessage) => void
    character_update: (data: { sessionId: string; characterId: string; updates: any }) => void
    ping: () => void
}

class SocketClient {
    private socket: Socket<ServerToClientEvents, ClientToServerEvents> | null = null
    private reconnectAttempts = 0
    private maxReconnectAttempts = 5
    private reconnectDelay = 1000

    connect(token: string): void {
        if (this.socket?.connected) {
            return
        }

        const socketUrl = process.env.NEXT_PUBLIC_SOCKET_URL || 'http://localhost:3001'

        this.socket = io(socketUrl, {
            auth: {
                token
            },
            autoConnect: true,
            reconnection: true,
            reconnectionAttempts: this.maxReconnectAttempts,
            reconnectionDelay: this.reconnectDelay,
            timeout: 10000
        })

        this.setupEventHandlers()
    }

    disconnect(): void {
        if (this.socket) {
            this.socket.disconnect()
            this.socket = null
        }
        useGameStore.getState().setConnectionStatus('disconnected')
    }

    private setupEventHandlers(): void {
        if (!this.socket) return

        const gameStore = useGameStore.getState()

        // –°–æ–±—ã—Ç–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
        this.socket.on('connect', () => {
            console.log('üîå Connected to game server')
            gameStore.setConnectionStatus('connected')
            this.reconnectAttempts = 0
            toast.success('–ü–æ–¥–∫–ª—é—á–µ–Ω –∫ —Å–µ—Ä–≤–µ—Ä—É –∏–≥—Ä—ã')
        })

        this.socket.on('disconnect', (reason) => {
            console.log('üíî Disconnected from game server:', reason)
            gameStore.setConnectionStatus('disconnected')

            if (reason === 'io server disconnect') {
                toast.error('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Ä–∞–∑–æ—Ä–≤–∞–Ω–æ —Å–µ—Ä–≤–µ—Ä–æ–º')
            }
        })

        this.socket.on('connect_error', (error) => {
            console.error('‚ùå Connection error:', error)
            gameStore.setConnectionStatus('error')

            this.reconnectAttempts++
            if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                toast.error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É')
            }
        })

        // –°–∏—Å—Ç–µ–º–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è
        this.socket.on('connected', (data) => {
            console.log('‚úÖ Server confirmed connection:', data.message)
        })

        this.socket.on('error', (data) => {
            console.error('üö® Server error:', data.message)
            toast.error(data.message)
        })

        // –°–æ–±—ã—Ç–∏—è —Å–µ—Å—Å–∏–∏
        this.socket.on('session_joined', (data) => {
            toast.success(`–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª–∏—Å—å –∫ —Å–µ—Å—Å–∏–∏`)
        })

        this.socket.on('session_state', (data) => {
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–µ—Å—Å–∏–∏
            if (data.session) {
                gameStore.setCurrentSession(data.session)
            }
            if (data.connectedPlayers) {
                // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω—ã—Ö –∏–≥—Ä–æ–∫–æ–≤
            }
        })

        this.socket.on('player_joined', (data) => {
            toast(`${data.username} –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ –∏–≥—Ä–µ`, {
                icon: 'üëã',
                duration: 3000
            })
        })

        this.socket.on('player_left', (data) => {
            toast(`${data.username} –ø–æ–∫–∏–Ω—É–ª –∏–≥—Ä—É`, {
                icon: 'üëã',
                duration: 3000
            })
        })

        // –ò–≥—Ä–æ–≤—ã–µ —Å–æ–±—ã—Ç–∏—è
        this.socket.on('game_action', (action) => {
            const actionLog: ActionLog = {
                id: `action_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                sessionId: action.sessionId,
                characterId: action.playerId,
                actionType: action.type,
                content: `${action.playerName}: ${action.content}`,
                metadata: action.metadata,
                timestamp: new Date(action.timestamp).toISOString()
            }

            gameStore.addActionLog(actionLog)
        })

        this.socket.on('ai_response', (response) => {
            const actionLog: ActionLog = {
                id: response.id,
                sessionId: gameStore.currentSession?.id || '',
                actionType: 'ai_response',
                content: response.content,
                metadata: {
                    responseType: response.requestType,
                    suggestions: response.suggestions,
                    diceRollsRequired: response.diceRollsRequired,
                    sceneUpdates: response.sceneUpdates
                },
                timestamp: response.timestamp
            }

            gameStore.addActionLog(actionLog)
            gameStore.setLastAIResponse(response)
            gameStore.setPendingAIRequest(false)

            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—Ç–≤–µ—Ç–µ –ò–ò
            toast('üé≠ –ú–∞—Å—Ç–µ—Ä –æ—Ç–≤–µ—Ç–∏–ª', {
                duration: 2000
            })
        })

        this.socket.on('dice_roll', (rollResult) => {
            const diceRoll = {
                id: `roll_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                type: rollResult.type as any,
                result: rollResult.result,
                modifier: rollResult.modifier,
                total: rollResult.total,
                advantage: rollResult.advantage,
                disadvantage: rollResult.disadvantage,
                timestamp: new Date(rollResult.timestamp)
            }

            gameStore.addDiceRoll(diceRoll)

            const actionLog: ActionLog = {
                id: `dice_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                sessionId: gameStore.currentSession?.id || '',
                characterId: rollResult.characterId,
                actionType: 'dice_roll',
                content: `${rollResult.playerName} –±—Ä–æ—Å–∏–ª ${rollResult.type}: ${rollResult.result} + ${rollResult.modifier} = ${rollResult.total}`,
                diceRolls: [rollResult],
                timestamp: new Date(rollResult.timestamp).toISOString()
            }

            gameStore.addActionLog(actionLog)
        })

        this.socket.on('chat_message', (message) => {
            const actionLog: ActionLog = {
                id: `chat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                sessionId: message.sessionId,
                actionType: 'chat_message',
                content: `${message.playerName}: ${message.message}`,
                metadata: {
                    type: message.type,
                    playerId: message.playerId
                },
                timestamp: new Date(message.timestamp).toISOString()
            }

            gameStore.addActionLog(actionLog)
        })

        this.socket.on('character_update', (update) => {
            const character = gameStore.getCharacterById(update.characterId)
            if (character) {
                const updatedCharacter = { ...character, ...update.updates }
                gameStore.updateCharacter(updatedCharacter)
            }

            toast(`${update.updatedBy} –æ–±–Ω–æ–≤–∏–ª –ø–µ—Ä—Å–æ–Ω–∞–∂–∞`, {
                icon: 'üìù',
                duration: 2000
            })
        })

        // –ë–æ–µ–≤—ã–µ —Å–æ–±—ã—Ç–∏—è
        this.socket.on('combat_state_change', (data) => {
            const combatState: CombatState = {
                inCombat: data.inCombat,
                round: data.round || 0,
                turn: 0,
                initiativeOrder: []
            }

            gameStore.setCombatState(combatState)

            const message = data.inCombat ? '–ë–æ–π –Ω–∞—á–∞–ª—Å—è!' : '–ë–æ–π –∑–∞–≤–µ—Ä—à–µ–Ω!'
            toast(message, {
                icon: data.inCombat ? '‚öîÔ∏è' : 'üïäÔ∏è',
                duration: 3000
            })
        })

        this.socket.on('initiative_update', (data) => {
            const combatState = gameStore.combatState
            if (combatState) {
                gameStore.setCombatState({
                    ...combatState,
                    initiativeOrder: data.initiativeOrder
                })
            }
        })

        this.socket.on('player_turn', (data) => {
            toast(`–•–æ–¥ –∏–≥—Ä–æ–∫–∞: ${data.playerName}`, {
                icon: 'üé≤',
                duration: 4000
            })
        })

        // –°–æ–±—ã—Ç–∏—è –º–∏—Ä–∞
        this.socket.on('scene_change', (data) => {
            const actionLog: ActionLog = {
                id: `scene_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                sessionId: gameStore.currentSession?.id || '',
                actionType: 'scene_change',
                content: data.description,
                metadata: {
                    scene: data.scene,
                    imageUrl: data.imageUrl
                },
                timestamp: new Date(data.timestamp).toISOString()
            }

            gameStore.addActionLog(actionLog)

            toast('–°—Ü–µ–Ω–∞ –∏–∑–º–µ–Ω–∏–ª–∞—Å—å', {
                icon: 'üé¨',
                duration: 3000
            })
        })

        this.socket.on('quest_update', (data) => {
            const actionLog: ActionLog = {
                id: `quest_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                sessionId: gameStore.currentSession?.id || '',
                actionType: 'quest_update',
                content: `–ö–≤–µ—Å—Ç "${data.questName}": ${data.status}`,
                metadata: data,
                timestamp: new Date(data.timestamp).toISOString()
            }

            gameStore.addActionLog(actionLog)
        })

        this.socket.on('game_event', (data) => {
            toast(`–ò–≥—Ä–æ–≤–æ–µ —Å–æ–±—ã—Ç–∏–µ: ${data.type}`, {
                icon: '‚ú®',
                duration: 3000
            })
        })

        // Ping-pong –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
        this.socket.on('pong', (data) => {
            const latency = Date.now() - data.timestamp
            console.log(`üèì Ping: ${latency}ms`)
        })

        this.socket.on('force_disconnect', (data) => {
            toast.error(`–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –æ—Ç–∫–ª—é—á–µ–Ω–∏–µ: ${data.reason}`)
            this.disconnect()
        })
    }

    // –ú–µ—Ç–æ–¥—ã –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–±—ã—Ç–∏–π
    joinSession(sessionId: string): void {
        if (this.socket?.connected) {
            this.socket.emit('join_session', { sessionId })
            useGameStore.getState().setConnectionStatus('connecting')
        }
    }

    leaveSession(sessionId: string): void {
        if (this.socket?.connected) {
            this.socket.emit('leave_session', { sessionId })
        }
    }

    sendGameAction(action: SocketGameAction): void {
        if (this.socket?.connected) {
            this.socket.emit('game_action', action)
            useGameStore.getState().setPendingAIRequest(true)
        }
    }

    sendDiceRoll(diceRoll: SocketDiceRoll): void {
        if (this.socket?.connected) {
            this.socket.emit('dice_roll', diceRoll)
        }
    }

    sendChatMessage(message: SocketChatMessage): void {
        if (this.socket?.connected) {
            this.socket.emit('chat_message', message)
        }
    }

    updateCharacter(sessionId: string, characterId: string, updates: any): void {
        if (this.socket?.connected) {
            this.socket.emit('character_update', { sessionId, characterId, updates })
        }
    }

    getSessionState(sessionId: string): void {
        if (this.socket?.connected) {
            this.socket.emit('get_session_state', { sessionId })
        }
    }

    ping(): void {
        if (this.socket?.connected) {
            this.socket.emit('ping')
        }
    }

    // –£—Ç–∏–ª–∏—Ç—ã
    isConnected(): boolean {
        return this.socket?.connected || false
    }

    getSocketId(): string | undefined {
        return this.socket?.id
    }
}

// –°–æ–∑–¥–∞–µ–º –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä
export const socketClient = new SocketClient()

// –•—É–∫ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞—Ö
export const useSocket = () => {
    const isAuthenticated = useAuthStore(state => state.isAuthenticated)
    const token = useAuthStore(state => state.token)
    const connectionStatus = useGameStore(state => state.connectionStatus)

    const connect = () => {
        if (isAuthenticated && token && !socketClient.isConnected()) {
            socketClient.connect(token)
        }
    }

    const disconnect = () => {
        socketClient.disconnect()
    }

    return {
        connect,
        disconnect,
        isConnected: socketClient.isConnected(),
        connectionStatus,
        socket: socketClient
    }
}